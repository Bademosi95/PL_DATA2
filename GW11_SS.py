import streamlit as st
import pandas as pd
import numpy as np
import pickle
from scipy.stats import poisson

st.set_page_config(
    page_title="KB Premier League Match Predictor",
    layout="wide"
)

# ==============================
#       BASIC STYLING
# ==============================
CUSTOM_CSS = """
<style>
    .main-title { font-size: 30px; font-weight: 800; margin-bottom: 2px; }
    .sub-title { font-size: 14px; color: #9CA3AF; margin-bottom: 18px; }
    .model-card {
        border-radius: 12px; padding: 16px 18px;
        background-color: #0B1120; color: #F9FAFB; border: 1px solid #111827;
    }
    .model-card h4 { margin-top: 0; margin-bottom: 6px; }
    .model-metric-row { display: flex; justify-content: space-between; font-size: 14px; margin: 2px 0; }
    .model-metric-label { color: #9CA3AF; }
    .model-metric-value { font-weight: 600; }
    .footer-note { margin-top: 20px; font-size: 11px; color: #6B7280; text-align: left; }
</style>
"""
st.markdown(CUSTOM_CSS, unsafe_allow_html=True)

# ==============================
#       LOAD OBJECTS
# ==============================
@st.cache_resource
def load_data():
    # Load all pickles generated by weekly_update.py
    pipe = pickle.load(open("pipe_result_final.pkl", "rb"))
    pois = pickle.load(open("poisson_model.pkl", "rb"))
    ldf  = pickle.load(open("long_df.pkl", "rb"))
    sts  = pickle.load(open("stats.pkl", "rb"))
    rho  = pickle.load(open("rho_hat.pkl", "rb"))
    
    # Try loading feature cols, otherwise define manually (fallback)
    try:
        fcols = pickle.load(open("feature_cols.pkl", "rb"))
    except FileNotFoundError:
        fcols = [
            "strength_diff", "defense_diff",
            "rolling_points_diff", "rolling_xG_diff",
            "rolling_GD_diff", "finishing_overperf_diff"
        ]
    
    return pipe, pois, ldf, sts, rho, fcols

pipe_result_final, poisson_model, long_df, stats, rho_hat, feature_cols = load_data()

# Normalise team names for safety
if "Squad" in stats.columns:
    stats["Squad"] = stats["Squad"].astype(str).str.strip()
long_df["team"] = long_df["team"].astype(str).str.strip()

# ==============================
#     HELPER FUNCTIONS
# ==============================
def pct(x, decimals=1):
    return f"{x * 100:.{decimals}f}%"

def build_feature_row_for_match(home_team, away_team):
    """
    Reconstructs the exact feature row used by the Logistic Regression.
    It pulls the LATEST available stats from long_df for both teams.
    """
    # Get the most recent row for Home and Away teams
    # Since long_df is sorted by Date, .iloc[-1] gives the latest state
    h_row = long_df[long_df["team"] == home_team].iloc[-1]
    a_row = long_df[long_df["team"] == away_team].iloc[-1]

    # 1. Calculate Strength Metrics (Static from stats file, merged into long_df)
    # Note: In the new backend, these are named att_strength_home/away etc.
    h_att = h_row["att_strength_home"]
    h_def = h_row["def_weakness_home"]
    a_att = a_row["att_strength_away"]
    a_def = a_row["def_weakness_away"]

    strength_diff = h_att - a_att
    defense_diff  = a_def - h_def # Note: Def weakness reversal usually handled in logic

    # 2. Calculate Rolling Diffs
    # We grab the rolling stats directly. 
    # Note: In the backend, we already Shifted them. So the row representing 
    # the "Latest Game" actually contains the rolling stats *entering* that game.
    # For a *future* prediction, using the latest game's rolling stats is the best proxy.
    
    rolling_points_diff = h_row["rolling_points"] - a_row["rolling_points"]
    rolling_xg_diff     = h_row["rolling_xg_for"] - a_row["rolling_xg_for"]
    rolling_gd_diff     = h_row["rolling_GD"] - a_row["rolling_GD"]
    
    # Finishing overperformance
    fin_diff = h_row["rolling_finishing_overperf"] - a_row["rolling_finishing_overperf"]

    # Create Dictionary
    data = {
        "strength_diff": strength_diff,
        "defense_diff": defense_diff,
        "rolling_points_diff": rolling_points_diff,
        "rolling_xG_diff": rolling_xg_diff,
        "rolling_GD_diff": rolling_gd_diff,
        "finishing_overperf_diff": fin_diff
    }

    # Return DataFrame with columns in exact order of training
    return pd.DataFrame([data])[feature_cols]

def get_expected_goals_poisson(home_team, away_team, context_adj: float = 0.0):
    # Predict raw Lambdas using the GLM
    # The model formula was: "goals_for ~ C(team) + C(opponent) + is_home"
    
    # Home xG
    df_h = pd.DataFrame({"team": [home_team], "opponent": [away_team], "is_home": [1]})
    lam_home_base = float(poisson_model.predict(df_h).iloc[0])
    
    # Away xG
    df_a = pd.DataFrame({"team": [away_team], "opponent": [home_team], "is_home": [0]})
    lam_away_base = float(poisson_model.predict(df_a).iloc[0])

    # Apply Context Adjustment
    lam_home = max(lam_home_base * (1 + context_adj), 0.01)
    lam_away = max(lam_away_base * (1 - context_adj), 0.01)

    return lam_home, lam_away, lam_home_base, lam_away_base

def poisson_score_matrix(home_team, away_team, max_goals=6, context_adj: float = 0.0):
    lam_h, lam_a, lam_h_base, lam_a_base = get_expected_goals_poisson(
        home_team, away_team, context_adj=context_adj
    )
    hg = np.arange(0, max_goals + 1)
    ag = np.arange(0, max_goals + 1)
    P = np.zeros((len(hg), len(ag)))

    for i, h in enumerate(hg):
        for j, a in enumerate(ag):
            P[i, j] = poisson.pmf(h, lam_h) * poisson.pmf(a, lam_a)

    P /= P.sum()
    return hg, ag, P, lam_h, lam_a, lam_h_base, lam_a_base

def poisson_match_markets(home_team, away_team, max_goals=6, context_adj: float = 0.0):
    hg, ag, P, lam_h, lam_a, lam_h_base, lam_a_base = poisson_score_matrix(
        home_team, away_team, max_goals=max_goals, context_adj=context_adj
    )
    total = hg[:, None] + ag[None, :]
    return {
        "lambda_home": lam_h, "lambda_away": lam_a,
        "P_over_1_5": float(P[total >= 2].sum()),
        "P_over_2_5": float(P[total >= 3].sum()),
        "P_over_3_5": float(P[total >= 4].sum()),
        "P_BTTS": float(P[(hg[:, None] > 0) & (ag[None, :] > 0)].sum()),
    }

def dixon_coles_tau(hg, ag, lam_h, lam_a, rho):
    if hg == 0 and ag == 0: return 1 - (lam_h * lam_a * rho)
    if hg == 0 and ag == 1: return 1 + lam_a * rho
    if hg == 1 and ag == 0: return 1 + lam_h * rho
    if hg == 1 and ag == 1: return 1 - rho
    return 1.0

def dixon_coles_match_markets(home_team, away_team, rho, max_goals=6, context_adj: float = 0.0):
    hg, ag, P, lam_h, lam_a, lam_h_base, lam_a_base = poisson_score_matrix(
        home_team, away_team, max_goals=max_goals, context_adj=context_adj
    )
    # Apply DC Correction
    for i, h in enumerate(hg):
        for j, a in enumerate(ag):
            P[i, j] *= dixon_coles_tau(h, a, lam_h, lam_a, rho)
            
    P /= P.sum() # Renormalize
    total = hg[:, None] + ag[None, :]

    return {
        "P_home": float(np.tril(P, -1).sum()),
        "P_draw": float(np.trace(P)),
        "P_away": float(np.triu(P, 1).sum()),
        "P_over_1_5": float(P[total >= 2].sum()),
        "P_over_2_5": float(P[total >= 3].sum()),
        "P_BTTS": float(P[(hg[:, None] > 0) & (ag[None, :] > 0)].sum()),
    }

def get_team_position(team):
    row = stats[stats["Squad"] == team]
    if "Position" in row.columns:
        return row["Position"].iloc[0]
    elif "Rk" in row.columns:
        return row["Rk"].iloc[0]
    return "â€“"

def last_5_results(team):
    # Filter for team matches
    df_team = long_df[long_df["team"] == team].sort_values("Date").tail(5)
    letters, icons = [], []
    for _, r in df_team.iterrows():
        # Determine W/D/L based on goals
        if r["goals_for"] > r["goals_against"]:
            letters.append("W"); icons.append("ðŸŸ©")
        elif r["goals_for"] == r["goals_against"]:
            letters.append("D"); icons.append("ðŸŸ¨")
        else:
            letters.append("L"); icons.append("ðŸŸ¥")
    return "".join(letters), "".join(icons)

# ==============================
#           SIDEBAR
# ==============================
with st.sidebar:
    st.header("Match Setup")
    teams = sorted(long_df["team"].unique()) # Use long_df teams to ensure consistency

    home_team = st.selectbox("Home team", teams)
    away_team = st.selectbox("Away team", teams)
    st.markdown("---")
    
    advanced_mode = st.checkbox("Real Life Context Mode", value=False)
    
    if not advanced_mode:
        context_adj = st.slider("Context Adjustment", -3.0, 3.0, 0.0, 0.1) / 10.0
    else:
        st.subheader("Advanced Controls")
        att_adj = st.slider("Attack Boost", -3.0, 3.0, 0.0, 0.1)
        def_adj = st.slider("Defense Boost", -3.0, 3.0, 0.0, 0.1)
        mor_adj = st.slider("Morale", -3.0, 3.0, 0.0, 0.1)
        context_adj = (att_adj + def_adj + 0.5 * mor_adj) / 20.0

    st.markdown(f"**Adjustment Factor:** `{context_adj:+.3f}`")

# ==============================
#       MAIN AREA
# ==============================
if home_team == away_team:
    st.warning("Select different teams.")
    st.stop()

st.markdown('<div class="main-title">KB Premier League Predictor</div>', unsafe_allow_html=True)
st.markdown('<div class="sub-title">Logistic Regression Â· Poisson Â· Dixonâ€“Coles</div>', unsafe_allow_html=True)

st.markdown(f"### {home_team} vs {away_team}")

# 1. Calculate Probs
# Logistic
X_row = build_feature_row_for_match(home_team, away_team)
log_probs = pipe_result_final.predict_proba(X_row)[0]
classes = pipe_result_final.named_steps["clf"].classes_
p_log = dict(zip(classes, log_probs))

# Poisson / DC
pm = poisson_match_markets(home_team, away_team, context_adj=context_adj)
dc = dixon_coles_match_markets(home_team, away_team, rho_hat, context_adj=context_adj)
dc_base = dixon_coles_match_markets(home_team, away_team, rho_hat, context_adj=0.0)

# 2. Display Headlines
st.subheader("Prediction Overview")
colA, colB, colC = st.columns(3)
colA.metric("Home Win", pct(dc["P_home"]), delta=f"{(dc['P_home']-dc_base['P_home'])*100:.1f}%")
colB.metric("Draw", pct(dc["P_draw"]))
colC.metric("Away Win", pct(dc["P_away"]), delta=f"{(dc['P_away']-dc_base['P_away'])*100:.1f}%")

# 3. Model Cards
c1, c2, c3 = st.columns(3)

# Logistic
with c1:
    st.markdown('<div class="model-card"><h4>Logistic Baseline</h4>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Home</span><span>{pct(p_log.get("H",0))}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Draw</span><span>{pct(p_log.get("D",0))}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Away</span><span>{pct(p_log.get("A",0))}</span></div>', unsafe_allow_html=True)
    st.caption("Based on form (5 games) & season strength stats.")
    st.markdown('</div>', unsafe_allow_html=True)

# Poisson
with c2:
    st.markdown('<div class="model-card"><h4>Poisson xG</h4>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>xG Home</span><span>{pm["lambda_home"]:.2f}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>xG Away</span><span>{pm["lambda_away"]:.2f}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Over 2.5</span><span>{pct(pm["P_over_2_5"])}</span></div>', unsafe_allow_html=True)
    st.caption(f"Context adjusted by {context_adj:+.2f}")
    st.markdown('</div>', unsafe_allow_html=True)

# Dixon-Coles
with c3:
    st.markdown('<div class="model-card"><h4>Dixon-Coles</h4>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Home</span><span>{pct(dc["P_home"])}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Draw</span><span>{pct(dc["P_draw"])}</span></div>', unsafe_allow_html=True)
    st.markdown(f'<div class="model-metric-row"><span>Away</span><span>{pct(dc["P_away"])}</span></div>', unsafe_allow_html=True)
    st.caption(f"Rho correction: {rho_hat:.4f}")
    st.markdown('</div>', unsafe_allow_html=True)

# 4. Stats & Form
with st.expander("Team Form & Stats", expanded=True):
    col1, col2 = st.columns(2)
    
    h_ltr, h_ico = last_5_results(home_team)
    a_ltr, a_ico = last_5_results(away_team)
    
    h_stats = long_df[long_df["team"]==home_team].iloc[-1]
    a_stats = long_df[long_df["team"]==away_team].iloc[-1]
    
    with col1:
        st.subheader(home_team)
        st.markdown(f"**Pos:** {get_team_position(home_team)} | **Form:** {h_ico}")
        st.table(pd.DataFrame({
            "Metric": ["Rolling xG (5)", "Finishing Overperf (5)", "Defense Overperf (5)"],
            "Value": [
                f"{h_stats['rolling_xg_for']:.2f}",
                f"{h_stats['rolling_finishing_overperf']:+.2f}",
                f"{h_stats['rolling_def_overperf']:+.2f}"
            ]
        }))

    with col2:
        st.subheader(away_team)
        st.markdown(f"**Pos:** {get_team_position(away_team)} | **Form:** {a_ico}")
        st.table(pd.DataFrame({
            "Metric": ["Rolling xG (5)", "Finishing Overperf (5)", "Defense Overperf (5)"],
            "Value": [
                f"{a_stats['rolling_xg_for']:.2f}",
                f"{a_stats['rolling_finishing_overperf']:+.2f}",
                f"{a_stats['rolling_def_overperf']:+.2f}"
            ]
        }))

st.markdown('<div class="footer-note">Model refreshes weekly. Probabilities are estimates.</div>', unsafe_allow_html=True)


